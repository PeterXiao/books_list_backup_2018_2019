# blog-2019-08-11  微基准测试：以Java为例--如何使用Jmh做Java方法微基准测试

##  计算机有经典的名言： “error input， error output。”
 
 要得到正确的数据分析结果，首先你的采样数据或者“探针”获取的数据得是真实的。
 
 这里虽然讲的是java，但实际上 JVM语言都是通用的，大部分原则在所有的系统都是通用的。
 
 1. 隔离
 2. 去除带 jit/gc 的语言的预热等影响。
 3. 度量标准统一
 
 
 Java的常用微基准测试框架： jmh  [google caliper](https://github.com/google/caliper)
 
 详细 参见 https://github.com/PeterXiao/JMH-samples
 
     @BenchmarkMode： 测试类型，有以下几种可选：
     Throughput：吞吐量，即每秒执行可多少次。
     AverageTime：平均时间，即每次调用平均耗时。
     SampleTime：随机取样。
     SingleShotTime：顾名思义，只运行一次，一般用于测试冷启动性能。
     All：
     
     @Warmup：预热，一般为保证测试准确性，要预热几次。
     @Measurement：测量。
       iterations：测试多少轮。
       time：每轮时长。
       timeUnit：时间单位。
     @Fork：JMH fork出指定个数的进程测试。
     @Threads：每个测试进程的测试线程数量。
     @OutputTimeUnit：测试结果的时间单位。
     @Benchmark：标记某个方法进行基准测试，类比JUnit的@Test。
     @Param：指定同一个方法的不同参数。
     @State：标记某对象在指定Scope内共享，通过@Benchmark标记的方法参数注入，Scope分三种：
       Benchmark，所有线程共享实例。
       Group，线程组内共享实例。
       Thread，线程内共享实例。
     @Setup：配置了@State的类专用，类比JUnit的@Setup，在benchmark方法执行前state实例做的操作。
     @TearDown：配置了@State的类专用，类比JUnit的@TearDown，在benchmark方法执行后state实例做的操作。